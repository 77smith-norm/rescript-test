// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "@rescript/runtime/lib/es6/Belt_Array.js";
import * as Stdlib_Int from "@rescript/runtime/lib/es6/Stdlib_Int.js";
import * as Stdlib_Array from "@rescript/runtime/lib/es6/Stdlib_Array.js";
import * as Primitive_int from "@rescript/runtime/lib/es6/Primitive_int.js";

function make_rule(birth, survival) {
  return {
    birth: birth,
    survival: survival
  };
}

function rule_has_birth(rule, n) {
  return Belt_Array.some(rule.birth, x => x === n);
}

function rule_has_survival(rule, n) {
  return Belt_Array.some(rule.survival, x => x === n);
}

let conway_birth = [3];

let conway_survival = [
  2,
  3
];

let conway = {
  birth: conway_birth,
  survival: conway_survival
};

let highlife_birth = [
  3,
  6
];

let highlife_survival = [
  2,
  3
];

let highlife = {
  birth: highlife_birth,
  survival: highlife_survival
};

let maze_birth = [3];

let maze_survival = [
  1,
  2,
  3,
  4,
  5
];

let maze = {
  birth: maze_birth,
  survival: maze_survival
};

let dayAndNight_birth = [
  3,
  6,
  7,
  8
];

let dayAndNight_survival = [
  3,
  4,
  6,
  7,
  8
];

let dayAndNight = {
  birth: dayAndNight_birth,
  survival: dayAndNight_survival
};

function make_grid(rows, cols) {
  return Belt_Array.make(rows * cols | 0, "Dead");
}

function get_cell(grid, cols, r, c) {
  let cell = grid[(r * cols | 0) + c | 0];
  if (cell !== undefined) {
    return cell;
  } else {
    return "Dead";
  }
}

function set_cell(grid, cols, r, c, val) {
  Belt_Array.set(grid, (r * cols | 0) + c | 0, val);
}

function count_live_neighbors(grid, rows, cols, r, c) {
  let count = 0;
  let di = -1;
  while (di <= 1) {
    let dj = -1;
    while (dj <= 1) {
      if (di !== 0 || dj !== 0) {
        let nr = Primitive_int.mod_((r + di | 0) + rows | 0, rows);
        let nc = Primitive_int.mod_((c + dj | 0) + cols | 0, cols);
        if (get_cell(grid, cols, nr, nc) === "Alive") {
          count = count + 1 | 0;
        }
      }
      dj = dj + 1 | 0;
    };
    di = di + 1 | 0;
  };
  return count;
}

function compute_next_gen_rule(grid, rows, cols, rule) {
  let next = make_grid(rows, cols);
  let r = 0;
  while (r < rows) {
    let c = 0;
    while (c < cols) {
      let n = count_live_neighbors(grid, rows, cols, r, c);
      let match = get_cell(grid, cols, r, c);
      let new_cell;
      new_cell = match === "Alive" ? (
          rule_has_survival(rule, n) ? "Alive" : "Dead"
        ) : (
          rule_has_birth(rule, n) ? "Alive" : "Dead"
        );
      set_cell(next, cols, r, c, new_cell);
      c = c + 1 | 0;
    };
    r = r + 1 | 0;
  };
  return next;
}

function compute_next_gen(grid, rows, cols) {
  return compute_next_gen_rule(grid, rows, cols, conway);
}

function load_preset(p, rows, cols) {
  let grid = make_grid(rows, cols);
  let center_r = rows / 2 | 0;
  let center_c = cols / 2 | 0;
  switch (p) {
    case "Glider" :
      let offsets = [
        [
          0,
          1
        ],
        [
          1,
          2
        ],
        [
          2,
          0
        ],
        [
          2,
          1
        ],
        [
          2,
          2
        ]
      ];
      offsets.forEach(offset => {
        let r = 1 + offset[0] | 0;
        let c = 1 + offset[1] | 0;
        set_cell(grid, cols, r, c, "Alive");
      });
      break;
    case "Blinker" :
      let offsets$1 = [
        [
          0,
          0
        ],
        [
          0,
          1
        ],
        [
          0,
          2
        ]
      ];
      offsets$1.forEach(offset => set_cell(grid, cols, center_r + offset[0] | 0, (center_c - 1 | 0) + offset[1] | 0, "Alive"));
      break;
    case "Pulsar" :
      let offsets$2 = [
        [
          -4,
          -1
        ],
        [
          -4,
          -2
        ],
        [
          -4,
          -3
        ],
        [
          -4,
          1
        ],
        [
          -4,
          2
        ],
        [
          -4,
          3
        ],
        [
          -3,
          -1
        ],
        [
          -3,
          -2
        ],
        [
          -3,
          -3
        ],
        [
          -3,
          1
        ],
        [
          -3,
          2
        ],
        [
          -3,
          3
        ],
        [
          -2,
          -1
        ],
        [
          -2,
          -2
        ],
        [
          -2,
          -3
        ],
        [
          -2,
          1
        ],
        [
          -2,
          2
        ],
        [
          -2,
          3
        ],
        [
          -1,
          -4
        ],
        [
          -1,
          -3
        ],
        [
          -1,
          -2
        ],
        [
          -1,
          -1
        ],
        [
          -1,
          1
        ],
        [
          -1,
          2
        ],
        [
          -1,
          3
        ],
        [
          -1,
          4
        ],
        [
          1,
          -4
        ],
        [
          1,
          -3
        ],
        [
          1,
          -2
        ],
        [
          1,
          -1
        ],
        [
          1,
          1
        ],
        [
          1,
          2
        ],
        [
          1,
          3
        ],
        [
          1,
          4
        ],
        [
          2,
          -1
        ],
        [
          2,
          -2
        ],
        [
          2,
          -3
        ],
        [
          2,
          1
        ],
        [
          2,
          2
        ],
        [
          2,
          3
        ],
        [
          3,
          -1
        ],
        [
          3,
          -2
        ],
        [
          3,
          -3
        ],
        [
          3,
          1
        ],
        [
          3,
          2
        ],
        [
          3,
          3
        ],
        [
          4,
          -1
        ],
        [
          4,
          -2
        ],
        [
          4,
          -3
        ],
        [
          4,
          1
        ],
        [
          4,
          2
        ],
        [
          4,
          3
        ]
      ];
      offsets$2.forEach(offset => set_cell(grid, cols, center_r + offset[0] | 0, center_c + offset[1] | 0, "Alive"));
      break;
    case "RPentomino" :
      let offsets$3 = [
        [
          0,
          1
        ],
        [
          0,
          2
        ],
        [
          1,
          0
        ],
        [
          1,
          1
        ],
        [
          2,
          1
        ]
      ];
      offsets$3.forEach(offset => set_cell(grid, cols, center_r + offset[0] | 0, center_c + offset[1] | 0, "Alive"));
      break;
  }
  return grid;
}

let random_state = {
  contents: 12345
};

function next_rand() {
  let x = (random_state.contents * 1103515245 | 0) + 12345 | 0;
  random_state.contents = x & 2147483647;
  return random_state.contents;
}

function randomize_grid(rows, cols) {
  let grid = make_grid(rows, cols);
  let r = 0;
  while (r < rows) {
    let c = 0;
    while (c < cols) {
      let v = (next_rand() >>> 15) & 1;
      set_cell(grid, cols, r, c, v === 1 ? "Alive" : "Dead");
      c = c + 1 | 0;
    };
    r = r + 1 | 0;
  };
  return grid;
}

function count_alive(grid) {
  return Stdlib_Array.reduce(grid, 0, (acc, cell) => {
    if (cell === "Alive") {
      return acc + 1 | 0;
    } else {
      return acc;
    }
  });
}

function cellFromTouch(clientX, clientY, gridLeft, gridTop, cellSize, rows, cols) {
  let x = (clientX - gridLeft) / cellSize;
  let y = (clientY - gridTop) / cellSize;
  if (x < 0.0 || y < 0.0) {
    return;
  }
  let col = x | 0;
  let row = y | 0;
  if (col >= 0 && col < cols && row >= 0 && row < rows) {
    return [
      row,
      col
    ];
  }
}

function serialize_grid(grid) {
  return Stdlib_Array.reduce(grid, "", (acc, cell) => {
    let tmp;
    tmp = cell === "Alive" ? "1" : "0";
    return acc + tmp;
  });
}

function deserialize_grid(s) {
  return Stdlib_Array.fromInitializer(s.length, i => {
    let match = s[i];
    if (match === "1") {
      return "Alive";
    } else {
      return "Dead";
    }
  });
}

function make_ages(rows, cols) {
  return Belt_Array.make(rows * cols | 0, 0);
}

function get_age(ages, cols, r, c) {
  let age = Belt_Array.get(ages, (r * cols | 0) + c | 0);
  if (age !== undefined) {
    return age;
  } else {
    return 0;
  }
}

function set_age(ages, cols, r, c, value) {
  Belt_Array.set(ages, (r * cols | 0) + c | 0, value);
}

function count_nonzero_ages(ages) {
  return Stdlib_Array.reduce(ages, 0, (acc, age) => {
    if (age > 0) {
      return acc + 1 | 0;
    } else {
      return acc;
    }
  });
}

function compute_next_gen_with_age(grid, ages, rows, cols) {
  let next_grid = make_grid(rows, cols);
  let next_ages = make_ages(rows, cols);
  let r = 0;
  while (r < rows) {
    let c = 0;
    while (c < cols) {
      let n = count_live_neighbors(grid, rows, cols, r, c);
      let current_cell = get_cell(grid, cols, r, c);
      let current_age = get_age(ages, cols, r, c);
      let match;
      match = current_cell === "Alive" ? (
          n < 2 || n > 3 ? [
              "Dead",
              0
            ] : [
              "Alive",
              current_age + 1 | 0
            ]
        ) : (
          n === 3 ? [
              "Alive",
              1
            ] : [
              "Dead",
              0
            ]
        );
      set_cell(next_grid, cols, r, c, match[0]);
      set_age(next_ages, cols, r, c, match[1]);
      c = c + 1 | 0;
    };
    r = r + 1 | 0;
  };
  return [
    next_grid,
    next_ages
  ];
}

function compute_age_color(age) {
  let lightness = 20 + (age * 3 | 0) | 0;
  let capped_lightness = lightness > 80 ? 80 : lightness;
  return "hsl(200, 70%, " + capped_lightness.toString() + "%)";
}

function encode_rle(grid, rows, cols) {
  let sb = "";
  sb = "x = " + cols.toString() + ", y = " + rows.toString() + ", rule = B3/S23\n";
  let r = 0;
  while (r < rows) {
    let c = 0;
    let runChar;
    let runCount = 0;
    while (c < cols) {
      let cell = get_cell(grid, cols, r, c);
      let ch;
      ch = cell === "Alive" ? "o" : "b";
      let prevChar = runChar;
      if (prevChar !== undefined) {
        if (prevChar === ch) {
          runCount = runCount + 1 | 0;
        } else {
          if (runCount > 1) {
            sb = sb + runCount.toString();
          }
          sb = sb + prevChar;
          runChar = ch;
          runCount = 1;
        }
      } else {
        runChar = ch;
        runCount = 1;
      }
      c = c + 1 | 0;
    };
    let prevChar$1 = runChar;
    if (prevChar$1 !== undefined) {
      if (runCount > 1) {
        sb = sb + runCount.toString();
      }
      sb = sb + prevChar$1;
    }
    sb = sb + "\n";
    r = r + 1 | 0;
  };
  sb = sb + "!";
  return sb;
}

function parseDigits(s, start) {
  let len = s.length;
  let i = start;
  let num = 0;
  let stop = false;
  while (i < len && !stop) {
    let ch = s[i];
    if (ch !== undefined && ch >= "0" && ch <= "9") {
      let n = Stdlib_Int.fromString(ch, undefined);
      if (n !== undefined) {
        num = (num * 10 | 0) + n | 0;
      }
      i = i + 1 | 0;
    } else {
      stop = true;
    }
  };
  if (i > start) {
    return [
      num,
      i
    ];
  }
}

function decode_rle(s) {
  let cleaned = s.trim();
  if (cleaned.length === 0) {
    return;
  }
  let rows = {
    contents: 0
  };
  let cols = {
    contents: 0
  };
  let headerFound = {
    contents: false
  };
  let lines = cleaned.split("\n");
  lines.forEach(line => {
    let trimmedLine = line.trim();
    if (!(!headerFound.contents && trimmedLine.includes("x ="))) {
      return;
    }
    let parts = trimmedLine.split(",");
    parts.forEach(part => {
      let p = part.trim();
      if (p.includes("x =")) {
        let afterX = p.slice(p.indexOf("x =") + 3 | 0);
        let trimmedAfter = afterX.trim();
        let endIdx = trimmedAfter.indexOf(" ");
        let valStr = endIdx !== -1 ? trimmedAfter.slice(0, endIdx) : trimmedAfter;
        let n = Stdlib_Int.fromString(valStr, undefined);
        if (n !== undefined) {
          cols.contents = n;
          return;
        } else {
          return;
        }
      }
      if (!p.includes("y =")) {
        return;
      }
      let afterY = p.slice(p.indexOf("y =") + 3 | 0);
      let trimmedAfter$1 = afterY.trim();
      let endIdx$1 = trimmedAfter$1.indexOf(" ");
      let valStr$1 = endIdx$1 !== -1 ? trimmedAfter$1.slice(0, endIdx$1) : trimmedAfter$1;
      let n$1 = Stdlib_Int.fromString(valStr$1, undefined);
      if (n$1 !== undefined) {
        rows.contents = n$1;
        return;
      }
    });
    headerFound.contents = true;
  });
  if (rows.contents === 0 || cols.contents === 0) {
    return;
  }
  let grid = make_grid(rows.contents, cols.contents);
  let currentRow = {
    contents: 0
  };
  let currentCol = {
    contents: 0
  };
  let parsingBody = {
    contents: false
  };
  lines.forEach(line => {
    let trimmedLine = line.trim();
    if (!parsingBody.contents && trimmedLine.includes("x =")) {
      parsingBody.contents = true;
    }
    if (!(parsingBody.contents && trimmedLine !== "" && !trimmedLine.includes("x ="))) {
      return;
    }
    currentCol.contents = 0;
    let i = 0;
    let len = trimmedLine.length;
    while (i < len) {
      let ch = trimmedLine[i];
      if (ch !== undefined) {
        switch (ch) {
          case "!" :
            i = len;
            break;
          case "$" :
            currentRow.contents = currentRow.contents + 1 | 0;
            currentCol.contents = 0;
            i = i + 1 | 0;
            break;
          default:
            if (ch >= "0" && ch <= "9") {
              let match = parseDigits(trimmedLine, i);
              if (match !== undefined) {
                let newPos = match[1];
                let num = match[0];
                let nextCh = trimmedLine[newPos];
                if (nextCh !== undefined) {
                  switch (nextCh) {
                    case "b" :
                      let j = 0;
                      while (j < num && currentCol.contents < cols.contents) {
                        set_cell(grid, cols.contents, currentRow.contents, currentCol.contents, "Dead");
                        currentCol.contents = currentCol.contents + 1 | 0;
                        j = j + 1 | 0;
                      };
                      break;
                    case "o" :
                      let j$1 = 0;
                      while (j$1 < num && currentCol.contents < cols.contents) {
                        set_cell(grid, cols.contents, currentRow.contents, currentCol.contents, "Alive");
                        currentCol.contents = currentCol.contents + 1 | 0;
                        j$1 = j$1 + 1 | 0;
                      };
                      break;
                  }
                }
                i = newPos + 1 | 0;
              } else {
                i = i + 1 | 0;
              }
            } else {
              switch (ch) {
                case "b" :
                  if (currentCol.contents < cols.contents) {
                    set_cell(grid, cols.contents, currentRow.contents, currentCol.contents, "Dead");
                    currentCol.contents = currentCol.contents + 1 | 0;
                  }
                  i = i + 1 | 0;
                  break;
                case "o" :
                  if (currentCol.contents < cols.contents) {
                    set_cell(grid, cols.contents, currentRow.contents, currentCol.contents, "Alive");
                    currentCol.contents = currentCol.contents + 1 | 0;
                  }
                  i = i + 1 | 0;
                  break;
                default:
                  i = i + 1 | 0;
              }
            }
        }
      } else {
        i = i + 1 | 0;
      }
    };
    currentRow.contents = currentRow.contents + 1 | 0;
  });
  if (currentRow.contents > rows.contents) {
    return;
  } else {
    return [
      grid,
      rows.contents,
      cols.contents
    ];
  }
}

function encode_url_state(grid, rows, cols) {
  return rows.toString() + ":" + cols.toString() + ":" + btoa(serialize_grid(grid));
}

function safeAtob(s) {
  try {
    return atob(s);
  } catch (exn) {
    return;
  }
}

function decode_url_state(s) {
  let parts = s.split(":");
  if (parts.length !== 3) {
    return;
  }
  let rowStr = parts[0];
  let colStr = parts[1];
  let b64 = parts[2];
  let match = Stdlib_Int.fromString(rowStr, undefined);
  let match$1 = Stdlib_Int.fromString(colStr, undefined);
  if (match === undefined) {
    return;
  }
  if (match$1 === undefined) {
    return;
  }
  if (!(match > 0 && match$1 > 0)) {
    return;
  }
  let decoded = safeAtob(b64);
  if (decoded !== undefined && decoded.length === (match * match$1 | 0)) {
    return [
      deserialize_grid(decoded),
      match,
      match$1
    ];
  }
}

function reducer(state, action) {
  if (typeof action !== "object") {
    switch (action) {
      case "Toggle" :
        return {
          grid: state.grid,
          rows: state.rows,
          cols: state.cols,
          running: !state.running,
          speed: state.speed,
          generation: state.generation,
          rule: state.rule,
          ages: state.ages
        };
      case "Step" :
        let match = compute_next_gen_with_age(state.grid, state.ages, state.rows, state.cols);
        return {
          grid: match[0],
          rows: state.rows,
          cols: state.cols,
          running: state.running,
          speed: state.speed,
          generation: state.generation + 1 | 0,
          rule: state.rule,
          ages: match[1]
        };
      case "Clear" :
        let new_ages = make_ages(state.rows, state.cols);
        return {
          grid: make_grid(state.rows, state.cols),
          rows: state.rows,
          cols: state.cols,
          running: false,
          speed: state.speed,
          generation: 0,
          rule: state.rule,
          ages: new_ages
        };
      case "Randomize" :
        let new_ages$1 = make_ages(state.rows, state.cols);
        return {
          grid: randomize_grid(state.rows, state.cols),
          rows: state.rows,
          cols: state.cols,
          running: state.running,
          speed: state.speed,
          generation: 0,
          rule: state.rule,
          ages: new_ages$1
        };
    }
  } else {
    switch (action.TAG) {
      case "SetSpeed" :
        return {
          grid: state.grid,
          rows: state.rows,
          cols: state.cols,
          running: state.running,
          speed: action._0,
          generation: state.generation,
          rule: state.rule,
          ages: state.ages
        };
      case "ToggleCell" :
        let c = action._1;
        let r = action._0;
        let next_grid = state.grid.slice(0);
        let next_ages = state.ages.slice(0);
        let cur = get_cell(next_grid, state.cols, r, c);
        let tmp;
        tmp = cur === "Alive" ? "Dead" : "Alive";
        set_cell(next_grid, state.cols, r, c, tmp);
        return {
          grid: next_grid,
          rows: state.rows,
          cols: state.cols,
          running: state.running,
          speed: state.speed,
          generation: state.generation,
          rule: state.rule,
          ages: next_ages
        };
      case "LoadPreset" :
        let new_ages$2 = make_ages(state.rows, state.cols);
        return {
          grid: load_preset(action._0, state.rows, state.cols),
          rows: state.rows,
          cols: state.cols,
          running: false,
          speed: state.speed,
          generation: 0,
          rule: state.rule,
          ages: new_ages$2
        };
      case "LoadCustomPreset" :
        let new_ages$3 = make_ages(state.rows, state.cols);
        return {
          grid: action._0,
          rows: state.rows,
          cols: state.cols,
          running: false,
          speed: state.speed,
          generation: 0,
          rule: state.rule,
          ages: new_ages$3
        };
      case "SetRule" :
        return {
          grid: state.grid,
          rows: state.rows,
          cols: state.cols,
          running: state.running,
          speed: state.speed,
          generation: state.generation,
          rule: action._0,
          ages: state.ages
        };
      case "LoadUrlState" :
        let cols = action._2;
        let rows = action._1;
        let new_ages$4 = make_ages(rows, cols);
        return {
          grid: action._0,
          rows: rows,
          cols: cols,
          running: false,
          speed: state.speed,
          generation: 0,
          rule: state.rule,
          ages: new_ages$4
        };
    }
  }
}

let initial_state_grid = make_grid(20, 40);

let initial_state_ages = make_ages(20, 40);

let initial_state = {
  grid: initial_state_grid,
  rows: 20,
  cols: 40,
  running: false,
  speed: 100,
  generation: 0,
  rule: conway,
  ages: initial_state_ages
};

let rows = 20;

let cols = 40;

export {
  make_rule,
  rule_has_birth,
  rule_has_survival,
  conway,
  highlife,
  maze,
  dayAndNight,
  make_grid,
  get_cell,
  set_cell,
  count_live_neighbors,
  compute_next_gen_rule,
  compute_next_gen,
  load_preset,
  random_state,
  next_rand,
  randomize_grid,
  count_alive,
  cellFromTouch,
  serialize_grid,
  deserialize_grid,
  make_ages,
  get_age,
  set_age,
  count_nonzero_ages,
  compute_next_gen_with_age,
  compute_age_color,
  encode_rle,
  parseDigits,
  decode_rle,
  encode_url_state,
  safeAtob,
  decode_url_state,
  reducer,
  rows,
  cols,
  initial_state,
}
/* initial_state Not a pure module */
