// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "@rescript/runtime/lib/es6/Belt_Array.js";
import * as Stdlib_Array from "@rescript/runtime/lib/es6/Stdlib_Array.js";
import * as Primitive_int from "@rescript/runtime/lib/es6/Primitive_int.js";

function make_grid(rows, cols) {
  return Belt_Array.make(rows * cols | 0, "Dead");
}

function get_cell(grid, cols, r, c) {
  let cell = grid[(r * cols | 0) + c | 0];
  if (cell !== undefined) {
    return cell;
  } else {
    return "Dead";
  }
}

function set_cell(grid, cols, r, c, val) {
  Belt_Array.set(grid, (r * cols | 0) + c | 0, val);
}

function count_live_neighbors(grid, rows, cols, r, c) {
  let count = 0;
  let di = -1;
  while (di <= 1) {
    let dj = -1;
    while (dj <= 1) {
      if (di !== 0 || dj !== 0) {
        let nr = Primitive_int.mod_((r + di | 0) + rows | 0, rows);
        let nc = Primitive_int.mod_((c + dj | 0) + cols | 0, cols);
        if (get_cell(grid, cols, nr, nc) === "Alive") {
          count = count + 1 | 0;
        }
      }
      dj = dj + 1 | 0;
    };
    di = di + 1 | 0;
  };
  return count;
}

function compute_next_gen(grid, rows, cols) {
  let next = make_grid(rows, cols);
  let r = 0;
  while (r < rows) {
    let c = 0;
    while (c < cols) {
      let n = count_live_neighbors(grid, rows, cols, r, c);
      let match = get_cell(grid, cols, r, c);
      let new_cell;
      new_cell = match === "Alive" ? (
          n < 2 || n > 3 ? "Dead" : "Alive"
        ) : (
          n === 3 ? "Alive" : "Dead"
        );
      set_cell(next, cols, r, c, new_cell);
      c = c + 1 | 0;
    };
    r = r + 1 | 0;
  };
  return next;
}

function load_preset(p, rows, cols) {
  let grid = make_grid(rows, cols);
  let center_r = rows / 2 | 0;
  let center_c = cols / 2 | 0;
  switch (p) {
    case "Glider" :
      let offsets = [
        [
          0,
          1
        ],
        [
          1,
          2
        ],
        [
          2,
          0
        ],
        [
          2,
          1
        ],
        [
          2,
          2
        ]
      ];
      offsets.forEach(offset => {
        let r = 1 + offset[0] | 0;
        let c = 1 + offset[1] | 0;
        set_cell(grid, cols, r, c, "Alive");
      });
      break;
    case "Blinker" :
      let offsets$1 = [
        [
          0,
          0
        ],
        [
          0,
          1
        ],
        [
          0,
          2
        ]
      ];
      offsets$1.forEach(offset => set_cell(grid, cols, center_r + offset[0] | 0, (center_c - 1 | 0) + offset[1] | 0, "Alive"));
      break;
    case "Pulsar" :
      let offsets$2 = [
        [
          -4,
          -1
        ],
        [
          -4,
          -2
        ],
        [
          -4,
          -3
        ],
        [
          -4,
          1
        ],
        [
          -4,
          2
        ],
        [
          -4,
          3
        ],
        [
          -3,
          -1
        ],
        [
          -3,
          -2
        ],
        [
          -3,
          -3
        ],
        [
          -3,
          1
        ],
        [
          -3,
          2
        ],
        [
          -3,
          3
        ],
        [
          -2,
          -1
        ],
        [
          -2,
          -2
        ],
        [
          -2,
          -3
        ],
        [
          -2,
          1
        ],
        [
          -2,
          2
        ],
        [
          -2,
          3
        ],
        [
          -1,
          -4
        ],
        [
          -1,
          -3
        ],
        [
          -1,
          -2
        ],
        [
          -1,
          -1
        ],
        [
          -1,
          1
        ],
        [
          -1,
          2
        ],
        [
          -1,
          3
        ],
        [
          -1,
          4
        ],
        [
          1,
          -4
        ],
        [
          1,
          -3
        ],
        [
          1,
          -2
        ],
        [
          1,
          -1
        ],
        [
          1,
          1
        ],
        [
          1,
          2
        ],
        [
          1,
          3
        ],
        [
          1,
          4
        ],
        [
          2,
          -1
        ],
        [
          2,
          -2
        ],
        [
          2,
          -3
        ],
        [
          2,
          1
        ],
        [
          2,
          2
        ],
        [
          2,
          3
        ],
        [
          3,
          -1
        ],
        [
          3,
          -2
        ],
        [
          3,
          -3
        ],
        [
          3,
          1
        ],
        [
          3,
          2
        ],
        [
          3,
          3
        ],
        [
          4,
          -1
        ],
        [
          4,
          -2
        ],
        [
          4,
          -3
        ],
        [
          4,
          1
        ],
        [
          4,
          2
        ],
        [
          4,
          3
        ]
      ];
      offsets$2.forEach(offset => set_cell(grid, cols, center_r + offset[0] | 0, center_c + offset[1] | 0, "Alive"));
      break;
    case "RPentomino" :
      let offsets$3 = [
        [
          0,
          1
        ],
        [
          0,
          2
        ],
        [
          1,
          0
        ],
        [
          1,
          1
        ],
        [
          2,
          1
        ]
      ];
      offsets$3.forEach(offset => set_cell(grid, cols, center_r + offset[0] | 0, center_c + offset[1] | 0, "Alive"));
      break;
  }
  return grid;
}

let random_state = {
  contents: 12345
};

function next_rand() {
  let x = (random_state.contents * 1103515245 | 0) + 12345 | 0;
  random_state.contents = x & 2147483647;
  return random_state.contents;
}

function randomize_grid(rows, cols) {
  let grid = make_grid(rows, cols);
  let r = 0;
  while (r < rows) {
    let c = 0;
    while (c < cols) {
      let v = (next_rand() >>> 15) & 1;
      set_cell(grid, cols, r, c, v === 1 ? "Alive" : "Dead");
      c = c + 1 | 0;
    };
    r = r + 1 | 0;
  };
  return grid;
}

function count_alive(grid) {
  return Stdlib_Array.reduce(grid, 0, (acc, cell) => {
    if (cell === "Alive") {
      return acc + 1 | 0;
    } else {
      return acc;
    }
  });
}

function reducer(state, action) {
  if (typeof action !== "object") {
    switch (action) {
      case "Toggle" :
        return {
          grid: state.grid,
          rows: state.rows,
          cols: state.cols,
          running: !state.running,
          speed: state.speed,
          generation: state.generation
        };
      case "Step" :
        return {
          grid: compute_next_gen(state.grid, state.rows, state.cols),
          rows: state.rows,
          cols: state.cols,
          running: state.running,
          speed: state.speed,
          generation: state.generation + 1 | 0
        };
      case "Clear" :
        return {
          grid: make_grid(state.rows, state.cols),
          rows: state.rows,
          cols: state.cols,
          running: false,
          speed: state.speed,
          generation: 0
        };
      case "Randomize" :
        return {
          grid: randomize_grid(state.rows, state.cols),
          rows: state.rows,
          cols: state.cols,
          running: state.running,
          speed: state.speed,
          generation: 0
        };
    }
  } else {
    switch (action.TAG) {
      case "SetSpeed" :
        return {
          grid: state.grid,
          rows: state.rows,
          cols: state.cols,
          running: state.running,
          speed: action._0,
          generation: state.generation
        };
      case "ToggleCell" :
        let c = action._1;
        let r = action._0;
        let next = state.grid.slice(0);
        let cur = get_cell(next, state.cols, r, c);
        let tmp;
        tmp = cur === "Alive" ? "Dead" : "Alive";
        set_cell(next, state.cols, r, c, tmp);
        return {
          grid: next,
          rows: state.rows,
          cols: state.cols,
          running: state.running,
          speed: state.speed,
          generation: state.generation
        };
      case "LoadPreset" :
        return {
          grid: load_preset(action._0, state.rows, state.cols),
          rows: state.rows,
          cols: state.cols,
          running: false,
          speed: state.speed,
          generation: 0
        };
    }
  }
}

let initial_state_grid = make_grid(20, 40);

let initial_state = {
  grid: initial_state_grid,
  rows: 20,
  cols: 40,
  running: false,
  speed: 100,
  generation: 0
};

let rows = 20;

let cols = 40;

export {
  make_grid,
  get_cell,
  set_cell,
  count_live_neighbors,
  compute_next_gen,
  load_preset,
  random_state,
  next_rand,
  randomize_grid,
  count_alive,
  reducer,
  rows,
  cols,
  initial_state,
}
/* initial_state Not a pure module */
