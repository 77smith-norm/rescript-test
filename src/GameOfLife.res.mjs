// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "@rescript/runtime/lib/es6/Belt_Array.js";

function make_grid(rows, cols) {
  return Belt_Array.make(rows * cols | 0, "Dead");
}

function get_cell(grid, cols, r, c) {
  let cell = grid[(r * cols | 0) + c | 0];
  if (cell !== undefined) {
    return cell;
  } else {
    return "Dead";
  }
}

function set_cell(grid, cols, r, c, val) {
  Belt_Array.set(grid, (r * cols | 0) + c | 0, val);
}

function count_live_neighbors(grid, rows, cols, r, c) {
  let count = 0;
  let di = -1;
  while (di <= 1) {
    let dj = -1;
    while (dj <= 1) {
      if (di !== 0 || dj !== 0) {
        let nr = r + di | 0;
        let nc = c + dj | 0;
        if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && get_cell(grid, cols, nr, nc) === "Alive") {
          count = count + 1 | 0;
        }
      }
      dj = dj + 1 | 0;
    };
    di = di + 1 | 0;
  };
  return count;
}

function compute_next_gen(grid, rows, cols) {
  let next = make_grid(rows, cols);
  let r = 0;
  while (r < rows) {
    let c = 0;
    while (c < cols) {
      let n = count_live_neighbors(grid, rows, cols, r, c);
      let match = get_cell(grid, cols, r, c);
      let new_cell;
      new_cell = match === "Alive" ? (
          n < 2 || n > 3 ? "Dead" : "Alive"
        ) : (
          n === 3 ? "Alive" : "Dead"
        );
      set_cell(next, cols, r, c, new_cell);
      c = c + 1 | 0;
    };
    r = r + 1 | 0;
  };
  return next;
}

let random_state = {
  contents: 12345
};

function next_rand() {
  let x = (random_state.contents * 1103515245 | 0) + 12345 | 0;
  random_state.contents = x & 2147483647;
  return random_state.contents;
}

function randomize_grid(rows, cols) {
  let grid = make_grid(rows, cols);
  let r = 0;
  while (r < rows) {
    let c = 0;
    while (c < cols) {
      let v = (next_rand() >>> 15) & 1;
      set_cell(grid, cols, r, c, v === 1 ? "Alive" : "Dead");
      c = c + 1 | 0;
    };
    r = r + 1 | 0;
  };
  return grid;
}

function reducer(state, action) {
  if (typeof action !== "object") {
    switch (action) {
      case "Toggle" :
        return {
          grid: state.grid,
          rows: state.rows,
          cols: state.cols,
          running: !state.running,
          speed: state.speed
        };
      case "Step" :
        return {
          grid: compute_next_gen(state.grid, state.rows, state.cols),
          rows: state.rows,
          cols: state.cols,
          running: state.running,
          speed: state.speed
        };
      case "Clear" :
        return {
          grid: make_grid(state.rows, state.cols),
          rows: state.rows,
          cols: state.cols,
          running: false,
          speed: state.speed
        };
      case "Randomize" :
        return {
          grid: randomize_grid(state.rows, state.cols),
          rows: state.rows,
          cols: state.cols,
          running: state.running,
          speed: state.speed
        };
    }
  } else {
    if (action.TAG === "SetSpeed") {
      return {
        grid: state.grid,
        rows: state.rows,
        cols: state.cols,
        running: state.running,
        speed: action._0
      };
    }
    let c = action._1;
    let r = action._0;
    let next = state.grid.slice(0);
    let cur = get_cell(next, state.cols, r, c);
    let tmp;
    tmp = cur === "Alive" ? "Dead" : "Alive";
    set_cell(next, state.cols, r, c, tmp);
    return {
      grid: next,
      rows: state.rows,
      cols: state.cols,
      running: state.running,
      speed: state.speed
    };
  }
}

let initial_state_grid = make_grid(20, 40);

let initial_state = {
  grid: initial_state_grid,
  rows: 20,
  cols: 40,
  running: false,
  speed: 100
};

let rows = 20;

let cols = 40;

export {
  make_grid,
  get_cell,
  set_cell,
  count_live_neighbors,
  compute_next_gen,
  random_state,
  next_rand,
  randomize_grid,
  reducer,
  rows,
  cols,
  initial_state,
}
/* initial_state Not a pure module */
