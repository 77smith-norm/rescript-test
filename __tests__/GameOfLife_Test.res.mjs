// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Vitest from "rescript-vitest/src/Vitest.res.mjs";
import * as GameOfLife from "../src/GameOfLife.res.mjs";

Vitest.describe("make_grid", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, () => {
  Vitest.test("creates grid with correct total size (rows * cols)", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(3, 4);
    t.expect(grid.length).toBe(12);
  });
  Vitest.test("all cells initialized to Dead", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(5, 5);
    t.expect(GameOfLife.count_alive(grid)).toBe(0);
  });
});

Vitest.describe("get_cell and set_cell", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, () => {
  Vitest.test("set then get returns Alive", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(5, 5);
    GameOfLife.set_cell(grid, 5, 2, 3, "Alive");
    t.expect(GameOfLife.get_cell(grid, 5, 2, 3)).toBe("Alive");
  });
  Vitest.test("unset cell returns Dead", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(5, 5);
    t.expect(GameOfLife.get_cell(grid, 5, 1, 1)).toBe("Dead");
  });
  Vitest.test("out-of-bounds get returns Dead (not a crash)", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(5, 5);
    t.expect(GameOfLife.get_cell(grid, 5, 10, 10)).toBe("Dead");
  });
  Vitest.test("negative row index returns Dead", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(5, 5);
    t.expect(GameOfLife.get_cell(grid, 5, -1, 0)).toBe("Dead");
  });
  Vitest.test("set overwrites an existing value", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(5, 5);
    GameOfLife.set_cell(grid, 5, 2, 2, "Alive");
    GameOfLife.set_cell(grid, 5, 2, 2, "Dead");
    t.expect(GameOfLife.get_cell(grid, 5, 2, 2)).toBe("Dead");
  });
});

Vitest.describe("count_live_neighbors — finite boundary", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, () => {
  Vitest.test("isolated cell has 0 neighbors", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(5, 5);
    GameOfLife.set_cell(grid, 5, 2, 2, "Alive");
    t.expect(GameOfLife.count_live_neighbors(grid, 5, 5, 2, 2)).toBe(0);
  });
  Vitest.test("counts all 8 surrounding neighbors", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(5, 5);
    GameOfLife.set_cell(grid, 5, 1, 1, "Alive");
    GameOfLife.set_cell(grid, 5, 1, 2, "Alive");
    GameOfLife.set_cell(grid, 5, 1, 3, "Alive");
    GameOfLife.set_cell(grid, 5, 2, 1, "Alive");
    GameOfLife.set_cell(grid, 5, 2, 3, "Alive");
    GameOfLife.set_cell(grid, 5, 3, 1, "Alive");
    GameOfLife.set_cell(grid, 5, 3, 2, "Alive");
    GameOfLife.set_cell(grid, 5, 3, 3, "Alive");
    t.expect(GameOfLife.count_live_neighbors(grid, 5, 5, 2, 2)).toBe(8);
  });
  Vitest.test("cell itself is not counted as its own neighbor", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(5, 5);
    GameOfLife.set_cell(grid, 5, 2, 2, "Alive");
    t.expect(GameOfLife.count_live_neighbors(grid, 5, 5, 2, 2)).toBe(0);
  });
  Vitest.test("top-left corner has at most 3 in-bounds neighbors", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(5, 5);
    GameOfLife.set_cell(grid, 5, 0, 1, "Alive");
    GameOfLife.set_cell(grid, 5, 1, 0, "Alive");
    GameOfLife.set_cell(grid, 5, 1, 1, "Alive");
    t.expect(GameOfLife.count_live_neighbors(grid, 5, 5, 0, 0)).toBe(3);
  });
  Vitest.test("top edge cell counts only in-bounds neighbors", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(5, 5);
    GameOfLife.set_cell(grid, 5, 0, 1, "Alive");
    GameOfLife.set_cell(grid, 5, 0, 3, "Alive");
    GameOfLife.set_cell(grid, 5, 1, 1, "Alive");
    GameOfLife.set_cell(grid, 5, 1, 2, "Alive");
    GameOfLife.set_cell(grid, 5, 1, 3, "Alive");
    t.expect(GameOfLife.count_live_neighbors(grid, 5, 5, 0, 2)).toBe(5);
  });
  Vitest.test("bottom-right corner has at most 3 in-bounds neighbors", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(5, 5);
    GameOfLife.set_cell(grid, 5, 3, 3, "Alive");
    GameOfLife.set_cell(grid, 5, 3, 4, "Alive");
    GameOfLife.set_cell(grid, 5, 4, 3, "Alive");
    t.expect(GameOfLife.count_live_neighbors(grid, 5, 5, 4, 4)).toBe(3);
  });
});

Vitest.describe("compute_next_gen — Conway's rules", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, () => {
  Vitest.test("underpopulation: live cell with 0 neighbors dies", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(5, 5);
    GameOfLife.set_cell(grid, 5, 2, 2, "Alive");
    let next = GameOfLife.compute_next_gen(grid, 5, 5);
    t.expect(GameOfLife.get_cell(next, 5, 2, 2)).toBe("Dead");
  });
  Vitest.test("underpopulation: live cell with 1 neighbor dies", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(5, 5);
    GameOfLife.set_cell(grid, 5, 2, 2, "Alive");
    GameOfLife.set_cell(grid, 5, 2, 3, "Alive");
    let next = GameOfLife.compute_next_gen(grid, 5, 5);
    t.expect(GameOfLife.get_cell(next, 5, 2, 2)).toBe("Dead");
  });
  Vitest.test("survival: live cell with 2 neighbors survives", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(5, 5);
    GameOfLife.set_cell(grid, 5, 2, 1, "Alive");
    GameOfLife.set_cell(grid, 5, 2, 2, "Alive");
    GameOfLife.set_cell(grid, 5, 2, 3, "Alive");
    let next = GameOfLife.compute_next_gen(grid, 5, 5);
    t.expect(GameOfLife.get_cell(next, 5, 2, 2)).toBe("Alive");
  });
  Vitest.test("survival: live cell with 3 neighbors survives", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(5, 5);
    GameOfLife.set_cell(grid, 5, 2, 2, "Alive");
    GameOfLife.set_cell(grid, 5, 1, 1, "Alive");
    GameOfLife.set_cell(grid, 5, 1, 2, "Alive");
    GameOfLife.set_cell(grid, 5, 1, 3, "Alive");
    let next = GameOfLife.compute_next_gen(grid, 5, 5);
    t.expect(GameOfLife.get_cell(next, 5, 2, 2)).toBe("Alive");
  });
  Vitest.test("overpopulation: live cell with 4 neighbors dies", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(5, 5);
    GameOfLife.set_cell(grid, 5, 2, 2, "Alive");
    GameOfLife.set_cell(grid, 5, 1, 2, "Alive");
    GameOfLife.set_cell(grid, 5, 3, 2, "Alive");
    GameOfLife.set_cell(grid, 5, 2, 1, "Alive");
    GameOfLife.set_cell(grid, 5, 2, 3, "Alive");
    let next = GameOfLife.compute_next_gen(grid, 5, 5);
    t.expect(GameOfLife.get_cell(next, 5, 2, 2)).toBe("Dead");
  });
  Vitest.test("reproduction: dead cell with exactly 3 neighbors becomes alive", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(5, 5);
    GameOfLife.set_cell(grid, 5, 2, 1, "Alive");
    GameOfLife.set_cell(grid, 5, 2, 2, "Alive");
    GameOfLife.set_cell(grid, 5, 2, 3, "Alive");
    let next = GameOfLife.compute_next_gen(grid, 5, 5);
    t.expect(GameOfLife.get_cell(next, 5, 1, 2)).toBe("Alive");
    t.expect(GameOfLife.get_cell(next, 5, 3, 2)).toBe("Alive");
  });
  Vitest.test("dead cell with 2 neighbors stays dead", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(5, 5);
    GameOfLife.set_cell(grid, 5, 2, 2, "Alive");
    GameOfLife.set_cell(grid, 5, 2, 3, "Alive");
    let next = GameOfLife.compute_next_gen(grid, 5, 5);
    t.expect(GameOfLife.get_cell(next, 5, 2, 1)).toBe("Dead");
  });
  Vitest.test("dead cell with 4 neighbors stays dead", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(5, 5);
    GameOfLife.set_cell(grid, 5, 1, 2, "Alive");
    GameOfLife.set_cell(grid, 5, 3, 2, "Alive");
    GameOfLife.set_cell(grid, 5, 2, 1, "Alive");
    GameOfLife.set_cell(grid, 5, 2, 3, "Alive");
    let next = GameOfLife.compute_next_gen(grid, 5, 5);
    t.expect(GameOfLife.get_cell(next, 5, 2, 2)).toBe("Dead");
  });
  Vitest.test("blinker oscillates: horizontal → vertical → horizontal", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(7, 7);
    GameOfLife.set_cell(grid, 7, 3, 2, "Alive");
    GameOfLife.set_cell(grid, 7, 3, 3, "Alive");
    GameOfLife.set_cell(grid, 7, 3, 4, "Alive");
    let gen1 = GameOfLife.compute_next_gen(grid, 7, 7);
    t.expect(GameOfLife.get_cell(gen1, 7, 2, 3)).toBe("Alive");
    t.expect(GameOfLife.get_cell(gen1, 7, 3, 3)).toBe("Alive");
    t.expect(GameOfLife.get_cell(gen1, 7, 4, 3)).toBe("Alive");
    t.expect(GameOfLife.get_cell(gen1, 7, 3, 2)).toBe("Dead");
    t.expect(GameOfLife.get_cell(gen1, 7, 3, 4)).toBe("Dead");
    let gen2 = GameOfLife.compute_next_gen(gen1, 7, 7);
    t.expect(GameOfLife.get_cell(gen2, 7, 3, 2)).toBe("Alive");
    t.expect(GameOfLife.get_cell(gen2, 7, 3, 3)).toBe("Alive");
    t.expect(GameOfLife.get_cell(gen2, 7, 3, 4)).toBe("Alive");
    t.expect(GameOfLife.get_cell(gen2, 7, 2, 3)).toBe("Dead");
    t.expect(GameOfLife.get_cell(gen2, 7, 4, 3)).toBe("Dead");
  });
  Vitest.test("block (2x2) is a still life — never changes", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(6, 6);
    GameOfLife.set_cell(grid, 6, 2, 2, "Alive");
    GameOfLife.set_cell(grid, 6, 2, 3, "Alive");
    GameOfLife.set_cell(grid, 6, 3, 2, "Alive");
    GameOfLife.set_cell(grid, 6, 3, 3, "Alive");
    let next = GameOfLife.compute_next_gen(grid, 6, 6);
    t.expect(GameOfLife.count_alive(next)).toBe(4);
    t.expect(GameOfLife.get_cell(next, 6, 2, 2)).toBe("Alive");
    t.expect(GameOfLife.get_cell(next, 6, 2, 3)).toBe("Alive");
    t.expect(GameOfLife.get_cell(next, 6, 3, 2)).toBe("Alive");
    t.expect(GameOfLife.get_cell(next, 6, 3, 3)).toBe("Alive");
  });
  Vitest.test("empty grid stays empty", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(5, 5);
    let next = GameOfLife.compute_next_gen(grid, 5, 5);
    t.expect(GameOfLife.count_alive(next)).toBe(0);
  });
});

Vitest.describe("count_alive", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, () => {
  Vitest.test("empty grid returns 0", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(5, 5);
    t.expect(GameOfLife.count_alive(grid)).toBe(0);
  });
  Vitest.test("counts 3 live cells correctly", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(5, 5);
    GameOfLife.set_cell(grid, 5, 0, 0, "Alive");
    GameOfLife.set_cell(grid, 5, 2, 2, "Alive");
    GameOfLife.set_cell(grid, 5, 4, 4, "Alive");
    t.expect(GameOfLife.count_alive(grid)).toBe(3);
  });
  Vitest.test("full 3x3 grid counts 9", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(3, 3);
    let r = 0;
    while (r < 3) {
      let c = 0;
      while (c < 3) {
        GameOfLife.set_cell(grid, 3, r, c, "Alive");
        c = c + 1 | 0;
      };
      r = r + 1 | 0;
    };
    t.expect(GameOfLife.count_alive(grid)).toBe(9);
  });
});

Vitest.describe("count_live_neighbors — toroidal wrap-around", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, () => {
  Vitest.test("top-left corner (0,0) wraps to see bottom-right corner (rows-1, cols-1)", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(5, 5);
    GameOfLife.set_cell(grid, 5, 4, 4, "Alive");
    t.expect(GameOfLife.count_live_neighbors(grid, 5, 5, 0, 0)).toBe(1);
  });
  Vitest.test("top row wraps to see bottom row as neighbor", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(5, 5);
    GameOfLife.set_cell(grid, 5, 4, 2, "Alive");
    t.expect(GameOfLife.count_live_neighbors(grid, 5, 5, 0, 2)).toBe(1);
  });
  Vitest.test("bottom row wraps to see top row as neighbor", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(5, 5);
    GameOfLife.set_cell(grid, 5, 0, 2, "Alive");
    t.expect(GameOfLife.count_live_neighbors(grid, 5, 5, 4, 2)).toBe(1);
  });
  Vitest.test("left column wraps to see right column as neighbor", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(5, 5);
    GameOfLife.set_cell(grid, 5, 2, 4, "Alive");
    t.expect(GameOfLife.count_live_neighbors(grid, 5, 5, 2, 0)).toBe(1);
  });
  Vitest.test("right column wraps to see left column as neighbor", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(5, 5);
    GameOfLife.set_cell(grid, 5, 2, 0, "Alive");
    t.expect(GameOfLife.count_live_neighbors(grid, 5, 5, 2, 4)).toBe(1);
  });
  Vitest.test("corner cell always has exactly 8 neighbors (toroidal, not 3 like finite)", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(5, 5);
    let r = 0;
    while (r < 5) {
      let c = 0;
      while (c < 5) {
        if (r !== 0 || c !== 0) {
          GameOfLife.set_cell(grid, 5, r, c, "Alive");
        }
        c = c + 1 | 0;
      };
      r = r + 1 | 0;
    };
    t.expect(GameOfLife.count_live_neighbors(grid, 5, 5, 0, 0)).toBe(8);
  });
  Vitest.test("edge cell always has exactly 8 neighbors (toroidal, not 5 like finite)", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(5, 5);
    let r = 0;
    while (r < 5) {
      let c = 0;
      while (c < 5) {
        if (r !== 0 || c !== 2) {
          GameOfLife.set_cell(grid, 5, r, c, "Alive");
        }
        c = c + 1 | 0;
      };
      r = r + 1 | 0;
    };
    t.expect(GameOfLife.count_live_neighbors(grid, 5, 5, 0, 2)).toBe(8);
  });
});

Vitest.describe("compute_next_gen — toroidal wrap-around", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, () => {
  Vitest.test("blinker at bottom edge wraps: vertical arm appears at top row", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(7, 7);
    GameOfLife.set_cell(grid, 7, 6, 2, "Alive");
    GameOfLife.set_cell(grid, 7, 6, 3, "Alive");
    GameOfLife.set_cell(grid, 7, 6, 4, "Alive");
    let next = GameOfLife.compute_next_gen(grid, 7, 7);
    t.expect(GameOfLife.get_cell(next, 7, 5, 3)).toBe("Alive");
    t.expect(GameOfLife.get_cell(next, 7, 6, 3)).toBe("Alive");
    t.expect(GameOfLife.get_cell(next, 7, 0, 3)).toBe("Alive");
    t.expect(GameOfLife.get_cell(next, 7, 6, 2)).toBe("Dead");
    t.expect(GameOfLife.get_cell(next, 7, 6, 4)).toBe("Dead");
  });
  Vitest.test("blinker at right edge wraps: vertical arm appears at left column", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(7, 7);
    GameOfLife.set_cell(grid, 7, 2, 6, "Alive");
    GameOfLife.set_cell(grid, 7, 3, 6, "Alive");
    GameOfLife.set_cell(grid, 7, 4, 6, "Alive");
    let next = GameOfLife.compute_next_gen(grid, 7, 7);
    t.expect(GameOfLife.get_cell(next, 7, 3, 5)).toBe("Alive");
    t.expect(GameOfLife.get_cell(next, 7, 3, 6)).toBe("Alive");
    t.expect(GameOfLife.get_cell(next, 7, 3, 0)).toBe("Alive");
    t.expect(GameOfLife.get_cell(next, 7, 2, 6)).toBe("Dead");
    t.expect(GameOfLife.get_cell(next, 7, 4, 6)).toBe("Dead");
  });
});

Vitest.describe("serialize_grid", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, () => {
  Vitest.test("empty grid serializes to all-'0' string of correct length", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(3, 4);
    let s = GameOfLife.serialize_grid(grid);
    t.expect(s.length).toBe(12);
    t.expect(s).toBe("000000000000");
  });
  Vitest.test("Alive cell serializes to '1', Dead to '0'", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(2, 2);
    GameOfLife.set_cell(grid, 2, 0, 0, "Alive");
    GameOfLife.set_cell(grid, 2, 1, 1, "Alive");
    let s = GameOfLife.serialize_grid(grid);
    t.expect(s).toBe("1001");
  });
  Vitest.test("all-alive grid serializes to all-'1' string", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(2, 3);
    GameOfLife.set_cell(grid, 3, 0, 0, "Alive");
    GameOfLife.set_cell(grid, 3, 0, 1, "Alive");
    GameOfLife.set_cell(grid, 3, 0, 2, "Alive");
    GameOfLife.set_cell(grid, 3, 1, 0, "Alive");
    GameOfLife.set_cell(grid, 3, 1, 1, "Alive");
    GameOfLife.set_cell(grid, 3, 1, 2, "Alive");
    let s = GameOfLife.serialize_grid(grid);
    t.expect(s).toBe("111111");
  });
});

Vitest.describe("deserialize_grid", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, () => {
  Vitest.test("all-'0' string deserializes to all-Dead grid", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.deserialize_grid("000000000000");
    t.expect(GameOfLife.count_alive(grid)).toBe(0);
  });
  Vitest.test("'1' chars deserialize to Alive cells, '0' to Dead", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.deserialize_grid("0001");
    t.expect(GameOfLife.count_alive(grid)).toBe(1);
    t.expect(GameOfLife.get_cell(grid, 2, 1, 1)).toBe("Alive");
    t.expect(GameOfLife.get_cell(grid, 2, 0, 0)).toBe("Dead");
  });
  Vitest.test("round-trip: serialize then deserialize gives identical alive count", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let original = GameOfLife.make_grid(5, 5);
    GameOfLife.set_cell(original, 5, 1, 1, "Alive");
    GameOfLife.set_cell(original, 5, 2, 3, "Alive");
    GameOfLife.set_cell(original, 5, 4, 0, "Alive");
    let s = GameOfLife.serialize_grid(original);
    let restored = GameOfLife.deserialize_grid(s);
    t.expect(GameOfLife.count_alive(restored)).toBe(3);
  });
  Vitest.test("round-trip: serialize then deserialize gives identical cell positions", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let original = GameOfLife.make_grid(4, 4);
    GameOfLife.set_cell(original, 4, 0, 3, "Alive");
    GameOfLife.set_cell(original, 4, 3, 0, "Alive");
    let s = GameOfLife.serialize_grid(original);
    let restored = GameOfLife.deserialize_grid(s);
    t.expect(GameOfLife.get_cell(restored, 4, 0, 3)).toBe("Alive");
    t.expect(GameOfLife.get_cell(restored, 4, 3, 0)).toBe("Alive");
    t.expect(GameOfLife.get_cell(restored, 4, 0, 0)).toBe("Dead");
    t.expect(GameOfLife.get_cell(restored, 4, 3, 3)).toBe("Dead");
  });
});

Vitest.describe("rule type and presets", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, () => {
  Vitest.test("rule type exists with birth and survival arrays", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    t.expect(GameOfLife.conway.birth.length).toBe(1);
    t.expect(GameOfLife.conway.survival.length).toBe(2);
  });
  Vitest.test("conway rule is B3/S23", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    t.expect(GameOfLife.rule_has_birth(GameOfLife.conway, 3)).toBe(true);
    t.expect(GameOfLife.rule_has_birth(GameOfLife.conway, 2)).toBe(false);
    t.expect(GameOfLife.rule_has_survival(GameOfLife.conway, 2)).toBe(true);
    t.expect(GameOfLife.rule_has_survival(GameOfLife.conway, 3)).toBe(true);
    t.expect(GameOfLife.rule_has_survival(GameOfLife.conway, 1)).toBe(false);
  });
  Vitest.test("highlife rule is B36/S23", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    t.expect(GameOfLife.rule_has_birth(GameOfLife.highlife, 3)).toBe(true);
    t.expect(GameOfLife.rule_has_birth(GameOfLife.highlife, 6)).toBe(true);
    t.expect(GameOfLife.rule_has_birth(GameOfLife.highlife, 2)).toBe(false);
  });
  Vitest.test("maze rule is B3/S12345", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    t.expect(GameOfLife.rule_has_birth(GameOfLife.maze, 3)).toBe(true);
    t.expect(GameOfLife.rule_has_birth(GameOfLife.maze, 2)).toBe(false);
    t.expect(GameOfLife.rule_has_survival(GameOfLife.maze, 1)).toBe(true);
    t.expect(GameOfLife.rule_has_survival(GameOfLife.maze, 2)).toBe(true);
    t.expect(GameOfLife.rule_has_survival(GameOfLife.maze, 3)).toBe(true);
    t.expect(GameOfLife.rule_has_survival(GameOfLife.maze, 4)).toBe(true);
    t.expect(GameOfLife.rule_has_survival(GameOfLife.maze, 5)).toBe(true);
    t.expect(GameOfLife.rule_has_survival(GameOfLife.maze, 6)).toBe(false);
  });
  Vitest.test("dayAndNight rule is B3678/S34678", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    t.expect(GameOfLife.rule_has_birth(GameOfLife.dayAndNight, 3)).toBe(true);
    t.expect(GameOfLife.rule_has_birth(GameOfLife.dayAndNight, 6)).toBe(true);
    t.expect(GameOfLife.rule_has_birth(GameOfLife.dayAndNight, 7)).toBe(true);
    t.expect(GameOfLife.rule_has_birth(GameOfLife.dayAndNight, 8)).toBe(true);
    t.expect(GameOfLife.rule_has_birth(GameOfLife.dayAndNight, 2)).toBe(false);
    t.expect(GameOfLife.rule_has_survival(GameOfLife.dayAndNight, 3)).toBe(true);
    t.expect(GameOfLife.rule_has_survival(GameOfLife.dayAndNight, 4)).toBe(true);
    t.expect(GameOfLife.rule_has_survival(GameOfLife.dayAndNight, 6)).toBe(true);
    t.expect(GameOfLife.rule_has_survival(GameOfLife.dayAndNight, 7)).toBe(true);
    t.expect(GameOfLife.rule_has_survival(GameOfLife.dayAndNight, 8)).toBe(true);
    t.expect(GameOfLife.rule_has_survival(GameOfLife.dayAndNight, 2)).toBe(false);
  });
});

Vitest.describe("compute_next_gen with rule parameter", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, () => {
  Vitest.test("compute_next_gen accepts rule parameter", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(5, 5);
    GameOfLife.set_cell(grid, 5, 2, 2, "Alive");
    let next = GameOfLife.compute_next_gen_rule(grid, 5, 5, GameOfLife.conway);
    t.expect(GameOfLife.get_cell(next, 5, 2, 2)).toBe("Dead");
  });
  Vitest.test("conway rule produces same result as original hardcoded function", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(7, 7);
    GameOfLife.set_cell(grid, 7, 3, 2, "Alive");
    GameOfLife.set_cell(grid, 7, 3, 3, "Alive");
    GameOfLife.set_cell(grid, 7, 3, 4, "Alive");
    let next_old = GameOfLife.compute_next_gen(grid, 7, 7);
    let next_new = GameOfLife.compute_next_gen_rule(grid, 7, 7, GameOfLife.conway);
    t.expect(GameOfLife.count_alive(next_new)).toBe(GameOfLife.count_alive(next_old));
    t.expect(GameOfLife.get_cell(next_new, 7, 2, 3)).toBe(GameOfLife.get_cell(next_old, 7, 2, 3));
    t.expect(GameOfLife.get_cell(next_new, 7, 4, 3)).toBe(GameOfLife.get_cell(next_old, 7, 4, 3));
  });
  Vitest.test("highlife: dead cell with 6 neighbors becomes alive (B36)", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(5, 5);
    GameOfLife.set_cell(grid, 5, 1, 1, "Alive");
    GameOfLife.set_cell(grid, 5, 1, 2, "Alive");
    GameOfLife.set_cell(grid, 5, 1, 3, "Alive");
    GameOfLife.set_cell(grid, 5, 2, 1, "Alive");
    GameOfLife.set_cell(grid, 5, 2, 3, "Alive");
    GameOfLife.set_cell(grid, 5, 3, 2, "Alive");
    let next = GameOfLife.compute_next_gen_rule(grid, 5, 5, GameOfLife.highlife);
    t.expect(GameOfLife.get_cell(next, 5, 2, 2)).toBe("Alive");
    let next_conway = GameOfLife.compute_next_gen_rule(grid, 5, 5, GameOfLife.conway);
    t.expect(GameOfLife.get_cell(next_conway, 5, 2, 2)).toBe("Dead");
  });
  Vitest.test("rule without B3: dead cell with 3 neighbors stays dead", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(5, 5);
    GameOfLife.set_cell(grid, 5, 1, 2, "Alive");
    GameOfLife.set_cell(grid, 5, 2, 1, "Alive");
    GameOfLife.set_cell(grid, 5, 2, 3, "Alive");
    let noB3 = GameOfLife.make_rule([2], [
      2,
      3
    ]);
    let next = GameOfLife.compute_next_gen_rule(grid, 5, 5, noB3);
    t.expect(GameOfLife.get_cell(next, 5, 2, 2)).toBe("Dead");
    let grid2 = GameOfLife.make_grid(5, 5);
    GameOfLife.set_cell(grid2, 5, 2, 1, "Alive");
    GameOfLife.set_cell(grid2, 5, 2, 3, "Alive");
    let next2 = GameOfLife.compute_next_gen_rule(grid2, 5, 5, noB3);
    t.expect(GameOfLife.get_cell(next2, 5, 2, 2)).toBe("Alive");
  });
  Vitest.test("rule without S2: live cell with 2 neighbors dies", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let noS2 = GameOfLife.make_rule([3], [3]);
    let grid = GameOfLife.make_grid(5, 5);
    GameOfLife.set_cell(grid, 5, 2, 2, "Alive");
    GameOfLife.set_cell(grid, 5, 1, 2, "Alive");
    GameOfLife.set_cell(grid, 5, 3, 2, "Alive");
    let next = GameOfLife.compute_next_gen_rule(grid, 5, 5, noS2);
    t.expect(GameOfLife.get_cell(next, 5, 2, 2)).toBe("Dead");
    let grid3 = GameOfLife.make_grid(5, 5);
    GameOfLife.set_cell(grid3, 5, 2, 2, "Alive");
    GameOfLife.set_cell(grid3, 5, 1, 2, "Alive");
    GameOfLife.set_cell(grid3, 5, 3, 2, "Alive");
    GameOfLife.set_cell(grid3, 5, 2, 1, "Alive");
    let next3 = GameOfLife.compute_next_gen_rule(grid3, 5, 5, noS2);
    t.expect(GameOfLife.get_cell(next3, 5, 2, 2)).toBe("Alive");
  });
});

Vitest.describe("cell age tracking", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, () => {
  Vitest.test("make_ages creates array of correct size", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let ages = GameOfLife.make_ages(5, 4);
    t.expect(ages.length).toBe(20);
  });
  Vitest.test("all ages initialized to 0", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let ages = GameOfLife.make_ages(3, 3);
    t.expect(GameOfLife.count_nonzero_ages(ages)).toBe(0);
  });
  Vitest.test("get_age returns correct value", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let ages = GameOfLife.make_ages(5, 5);
    GameOfLife.set_age(ages, 5, 2, 3, 7);
    t.expect(GameOfLife.get_age(ages, 5, 2, 3)).toBe(7);
  });
  Vitest.test("set_age updates value", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let ages = GameOfLife.make_ages(5, 5);
    GameOfLife.set_age(ages, 5, 1, 1, 5);
    GameOfLife.set_age(ages, 5, 1, 1, 10);
    t.expect(GameOfLife.get_age(ages, 5, 1, 1)).toBe(10);
  });
  Vitest.test("out-of-bounds get_age returns 0", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let ages = GameOfLife.make_ages(5, 5);
    t.expect(GameOfLife.get_age(ages, 5, 10, 10)).toBe(0);
  });
});

Vitest.describe("compute_next_gen with age tracking", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, () => {
  Vitest.test("surviving cell increments age", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(5, 5);
    let ages = GameOfLife.make_ages(5, 5);
    GameOfLife.set_cell(grid, 5, 2, 2, "Alive");
    GameOfLife.set_age(ages, 5, 2, 2, 5);
    GameOfLife.set_cell(grid, 5, 1, 2, "Alive");
    GameOfLife.set_cell(grid, 5, 3, 2, "Alive");
    GameOfLife.set_cell(grid, 5, 2, 1, "Alive");
    let match = GameOfLife.compute_next_gen_with_age(grid, ages, 5, 5);
    t.expect(GameOfLife.get_cell(match[0], 5, 2, 2)).toBe("Alive");
    t.expect(GameOfLife.get_age(match[1], 5, 2, 2)).toBe(6);
  });
  Vitest.test("new birth sets age to 1", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(5, 5);
    let ages = GameOfLife.make_ages(5, 5);
    GameOfLife.set_cell(grid, 5, 1, 2, "Alive");
    GameOfLife.set_cell(grid, 5, 2, 1, "Alive");
    GameOfLife.set_cell(grid, 5, 2, 3, "Alive");
    let match = GameOfLife.compute_next_gen_with_age(grid, ages, 5, 5);
    t.expect(GameOfLife.get_cell(match[0], 5, 2, 2)).toBe("Alive");
    t.expect(GameOfLife.get_age(match[1], 5, 2, 2)).toBe(1);
  });
  Vitest.test("dead cell resets age to 0", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(5, 5);
    let ages = GameOfLife.make_ages(5, 5);
    GameOfLife.set_cell(grid, 5, 2, 2, "Alive");
    GameOfLife.set_age(ages, 5, 2, 2, 10);
    GameOfLife.set_cell(grid, 5, 2, 3, "Alive");
    let match = GameOfLife.compute_next_gen_with_age(grid, ages, 5, 5);
    t.expect(GameOfLife.get_cell(match[0], 5, 2, 2)).toBe("Dead");
    t.expect(GameOfLife.get_age(match[1], 5, 2, 2)).toBe(0);
  });
  Vitest.test("block still life: all cells age together", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(6, 6);
    let ages = GameOfLife.make_ages(6, 6);
    GameOfLife.set_cell(grid, 6, 2, 2, "Alive");
    GameOfLife.set_cell(grid, 6, 2, 3, "Alive");
    GameOfLife.set_cell(grid, 6, 3, 2, "Alive");
    GameOfLife.set_cell(grid, 6, 3, 3, "Alive");
    GameOfLife.set_age(ages, 6, 2, 2, 3);
    GameOfLife.set_age(ages, 6, 2, 3, 3);
    GameOfLife.set_age(ages, 6, 3, 2, 3);
    GameOfLife.set_age(ages, 6, 3, 3, 3);
    let match = GameOfLife.compute_next_gen_with_age(grid, ages, 6, 6);
    let match$1 = GameOfLife.compute_next_gen_with_age(grid, match[1], 6, 6);
    let match$2 = GameOfLife.compute_next_gen_with_age(grid, match$1[1], 6, 6);
    let match$3 = GameOfLife.compute_next_gen_with_age(grid, match$2[1], 6, 6);
    let match$4 = GameOfLife.compute_next_gen_with_age(grid, match$3[1], 6, 6);
    let ages5 = match$4[1];
    t.expect(GameOfLife.get_age(ages5, 6, 2, 2)).toBe(8);
    t.expect(GameOfLife.get_age(ages5, 6, 2, 3)).toBe(8);
    t.expect(GameOfLife.get_age(ages5, 6, 3, 2)).toBe(8);
    t.expect(GameOfLife.get_age(ages5, 6, 3, 3)).toBe(8);
  });
  Vitest.test("empty grid: all ages remain 0", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(5, 5);
    let ages = GameOfLife.make_ages(5, 5);
    let match = GameOfLife.compute_next_gen_with_age(grid, ages, 5, 5);
    t.expect(GameOfLife.count_alive(match[0])).toBe(0);
    t.expect(GameOfLife.count_nonzero_ages(match[1])).toBe(0);
  });
  Vitest.test("mix of births, deaths, and survivors in one generation", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(5, 5);
    let ages = GameOfLife.make_ages(5, 5);
    GameOfLife.set_cell(grid, 5, 2, 0, "Alive");
    GameOfLife.set_age(ages, 5, 2, 0, 4);
    GameOfLife.set_cell(grid, 5, 2, 2, "Alive");
    GameOfLife.set_age(ages, 5, 2, 2, 7);
    GameOfLife.set_cell(grid, 5, 1, 2, "Alive");
    GameOfLife.set_cell(grid, 5, 3, 2, "Alive");
    let match = GameOfLife.compute_next_gen_with_age(grid, ages, 5, 5);
    let next_ages = match[1];
    let next_grid = match[0];
    t.expect(GameOfLife.get_cell(next_grid, 5, 2, 0)).toBe("Dead");
    t.expect(GameOfLife.get_age(next_ages, 5, 2, 0)).toBe(0);
    t.expect(GameOfLife.get_cell(next_grid, 5, 2, 2)).toBe("Alive");
    t.expect(GameOfLife.get_age(next_ages, 5, 2, 2)).toBe(8);
    t.expect(GameOfLife.get_cell(next_grid, 5, 2, 3)).toBe("Alive");
    t.expect(GameOfLife.get_age(next_ages, 5, 2, 3)).toBe(1);
  });
});

Vitest.describe("compute_age_color", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, () => {
  Vitest.test("age 0 returns dark color", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let color = GameOfLife.compute_age_color(0);
    t.expect(color.length).not.toBe(0);
  });
  Vitest.test("age 1 returns distinct color from age 0", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let color0 = GameOfLife.compute_age_color(0);
    let color1 = GameOfLife.compute_age_color(1);
    t.expect(color0).not.toBe(color1);
  });
  Vitest.test("higher ages produce progressively lighter colors", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let c1 = GameOfLife.compute_age_color(1);
    let c10 = GameOfLife.compute_age_color(10);
    let c50 = GameOfLife.compute_age_color(50);
    t.expect(c1.length).not.toBe(0);
    t.expect(c10.length).not.toBe(0);
    t.expect(c50.length).not.toBe(0);
  });
});

Vitest.describe("encode_rle", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, () => {
  Vitest.test("empty grid encodes to empty-ish string with header", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(3, 3);
    let encoded = GameOfLife.encode_rle(grid, 3, 3);
    t.expect(encoded.length).not.toBe(0);
  });
  Vitest.test("single alive cell encodes correctly", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(3, 3);
    GameOfLife.set_cell(grid, 3, 1, 1, "Alive");
    let encoded = GameOfLife.encode_rle(grid, 3, 3);
    t.expect(encoded.includes("o")).toBe(true);
  });
  Vitest.test("glider encodes to something with multiple 'o' marks", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let grid = GameOfLife.make_grid(3, 3);
    GameOfLife.set_cell(grid, 3, 0, 1, "Alive");
    GameOfLife.set_cell(grid, 3, 1, 2, "Alive");
    GameOfLife.set_cell(grid, 3, 2, 0, "Alive");
    GameOfLife.set_cell(grid, 3, 2, 1, "Alive");
    GameOfLife.set_cell(grid, 3, 2, 2, "Alive");
    let encoded = GameOfLife.encode_rle(grid, 3, 3);
    t.expect(encoded.length).not.toBe(5);
  });
});

Vitest.describe("decode_rle", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, () => {
  Vitest.test("decodes empty grid (all b)", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let result = GameOfLife.decode_rle("x = 3, y = 3, rule = B3/S23\nbbbob\nbbbob\nbbbob!");
    if (result !== undefined) {
      t.expect(result[1]).toBe(3);
      t.expect(result[2]).toBe(3);
      return t.expect(GameOfLife.count_alive(result[0])).toBe(0);
    } else {
      return t.expect(true).toBe(true);
    }
  });
  Vitest.test("decodes single 'o' to single alive cell", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let result = GameOfLife.decode_rle("x = 1, y = 1, rule = B3/S23\no!");
    if (result === undefined) {
      return t.expect(true).toBe(true);
    }
    let grid = result[0];
    t.expect(GameOfLife.count_alive(grid)).toBe(1);
    t.expect(GameOfLife.get_cell(grid, result[2], 0, 0)).toBe("Alive");
  });
  Vitest.test("ignores header and rule line", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let result1 = GameOfLife.decode_rle("x = 2, y = 1, rule = B3/S23\noo!");
    let result2 = GameOfLife.decode_rle("x = 2, y = 1\noo!");
    if (result1 !== undefined && result2 !== undefined) {
      return t.expect(GameOfLife.count_alive(result1[0])).toBe(GameOfLife.count_alive(result2[0]));
    } else {
      return t.expect(true).toBe(true);
    }
  });
  Vitest.test("handles run-length compression (3o = ooo)", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let result = GameOfLife.decode_rle("x = 3, y = 1\nooo!");
    if (result === undefined) {
      return t.expect(true).toBe(true);
    }
    let grid = result[0];
    t.expect(GameOfLife.count_alive(grid)).toBe(3);
    t.expect(GameOfLife.get_cell(grid, 3, 0, 0)).toBe("Alive");
    t.expect(GameOfLife.get_cell(grid, 3, 0, 1)).toBe("Alive");
    t.expect(GameOfLife.get_cell(grid, 3, 0, 2)).toBe("Alive");
  });
  Vitest.test("handles $ as row separator", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let result = GameOfLife.decode_rle("x = 2, y = 2, rule = B3/S23\noo$\nbb!");
    if (result === undefined) {
      return t.expect(true).toBe(true);
    }
    let grid = result[0];
    t.expect(GameOfLife.count_alive(grid)).toBe(2);
    t.expect(GameOfLife.get_cell(grid, 2, 0, 0)).toBe("Alive");
    t.expect(GameOfLife.get_cell(grid, 2, 0, 1)).toBe("Alive");
    t.expect(GameOfLife.get_cell(grid, 2, 1, 0)).toBe("Dead");
    t.expect(GameOfLife.get_cell(grid, 2, 1, 1)).toBe("Dead");
  });
  Vitest.test("returns None for invalid RLE", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let result1 = GameOfLife.decode_rle("not valid rle at all");
    t.expect(result1).toBe(undefined);
    let result2 = GameOfLife.decode_rle("");
    t.expect(result2).toBe(undefined);
  });
});

Vitest.describe("RLE round-trip", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, () => {
  Vitest.test("encode then decode recovers original grid", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let original = GameOfLife.make_grid(5, 5);
    GameOfLife.set_cell(original, 5, 0, 0, "Alive");
    GameOfLife.set_cell(original, 5, 0, 4, "Alive");
    GameOfLife.set_cell(original, 5, 2, 2, "Alive");
    GameOfLife.set_cell(original, 5, 4, 0, "Alive");
    GameOfLife.set_cell(original, 5, 4, 4, "Alive");
    let encoded = GameOfLife.encode_rle(original, 5, 5);
    let decoded = GameOfLife.decode_rle(encoded);
    if (decoded === undefined) {
      return t.expect(true).toBe(true);
    }
    let grid = decoded[0];
    t.expect(GameOfLife.count_alive(grid)).toBe(GameOfLife.count_alive(original));
    t.expect(GameOfLife.get_cell(grid, 5, 0, 0)).toBe(GameOfLife.get_cell(original, 5, 0, 0));
    t.expect(GameOfLife.get_cell(grid, 5, 0, 4)).toBe(GameOfLife.get_cell(original, 5, 0, 4));
    t.expect(GameOfLife.get_cell(grid, 5, 2, 2)).toBe(GameOfLife.get_cell(original, 5, 2, 2));
    t.expect(GameOfLife.get_cell(grid, 5, 4, 0)).toBe(GameOfLife.get_cell(original, 5, 4, 0));
    t.expect(GameOfLife.get_cell(grid, 5, 4, 4)).toBe(GameOfLife.get_cell(original, 5, 4, 4));
  });
  Vitest.test("blinker round-trip preserves oscillation pattern", undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, t => {
    let original = GameOfLife.make_grid(5, 5);
    GameOfLife.set_cell(original, 5, 2, 1, "Alive");
    GameOfLife.set_cell(original, 5, 2, 2, "Alive");
    GameOfLife.set_cell(original, 5, 2, 3, "Alive");
    let encoded = GameOfLife.encode_rle(original, 5, 5);
    let decoded = GameOfLife.decode_rle(encoded);
    if (decoded === undefined) {
      return t.expect(true).toBe(true);
    }
    let grid = decoded[0];
    t.expect(GameOfLife.count_alive(grid)).toBe(3);
    t.expect(GameOfLife.get_cell(grid, 5, 2, 1)).toBe("Alive");
    t.expect(GameOfLife.get_cell(grid, 5, 2, 2)).toBe("Alive");
    t.expect(GameOfLife.get_cell(grid, 5, 2, 3)).toBe("Alive");
  });
});

/*  Not a pure module */
